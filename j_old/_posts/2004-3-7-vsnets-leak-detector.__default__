--- 
title: VS.Net's leak detector
mt_id: 35
layout: post
date: 2004-03-07 21:33:17 +00:00
---
Being too cheap to buy Purify, I finally had to figure out how to use the built-in leak detector in VS.Net. Turns out it's really easy. 
Suppose you turn on leak detection with this:

    _CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF);

Then you get a bunch of stuff when your app exits like this:

{144} normal block at 0x00325430, 20 bytes long.
 Data: < s   /gh  JJ Whv> 96 73 0E D9 16 2F 67 68 D4 F7 4A 4A D0 57 68 76 
{143} normal block at 0x003253E0, 20 bytes long.
 Data: <  > $^    G   M > 87 0C 3E 99 24 5E 0D 1C 06 B7 47 DE B3 12 4D C8 
{142} normal block at 0x00325390, 20 bytes long.
 Data: <)#   l  R I     > 29 23 BE 84 E1 6C D6 AE 52 90 49 F1 F1 BB E9 EB 
{123} normal block at 0x00324E38, 20 bytes long.
 Data: <Y~5 2"     -H  u> 59 7E 35 CF 32 22 F4 CC CF D3 90 2D 48 D3 8F 75 

It used to be that I'd stare long and hard at the bytes in the dump to try to recognize the block that was leaked. It was pretty exasperating.

This is the part I just figured out tonight:

    _CrtSetBreakAlloc(144);

If you put this line at the top of your program, it'll break on the 144th allocation event. Note that 144 is the number in the braces listed in the first leak above. So you see where the leaked memory was allocated! As long as your code run is sufficiently deterministic, you will find your leak after two runs.
